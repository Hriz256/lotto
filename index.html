<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="ammo.js"></script>
        <script src="./src/babylon"></script>
        <script src="./src/babylonjs.loaders"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);

            const light = new BABYLON.DirectionalLight("dir02", new BABYLON.Vector3(0, 20, 20), scene);
            // light.intensity = 0.75;
            // light.intensity = 0.7;

            const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / -2, Math.PI / 2, 30, new BABYLON.Vector3(0, 0, 15), scene);
            camera.attachControl(canvas, true);


            scene.enablePhysics(new BABYLON.Vector3(0, -70, 0), new BABYLON.AmmoJSPlugin());


            const materials = {
                createColor(color, hex) {
                    this[color] = new BABYLON.StandardMaterial(`${color}`, this.scene);
                    this[color].diffuseColor = new BABYLON.Color3.FromHexString(hex);
                    this[color].emissiveColor = new BABYLON.Color3.FromHexString(hex);

                    return this[color];
                },

                createTexture({ texture, format = 'jpg', transparent = false }) {
                    this[texture] = new BABYLON.StandardMaterial(`${texture}`, this.scene);
                    this[texture].diffuseTexture = new BABYLON.Texture(`https://raw.githubusercontent.com/Hriz256/lotto/master/src/assets/${texture}.${format}`, this.scene);
                    this[texture].diffuseTexture.hasAlpha = transparent;

                    return this[texture];
                },

                createGlass() {
                    this.glass = new BABYLON.PBRMaterial("plastic", this.scene);
                    // plastic.reflectionTexture = hdrTexture;
                    this.glass.microSurface = 0.96;
                    this.glass.backFaceCulling = false;
                    this.glass.alpha = 0.2;
                    this.glass.albedoColor = new BABYLON.Color3(0.206, 0.94, 1);
                    this.glass.reflectivityColor = new BABYLON.Color3(0.003, 0.003, 0.003);
                },
            };

            materials.createColor('yellow', '#ffed45');

            const mesh = {
                createSphere({ diameter, ...generalParams }) {
                    const sphere = BABYLON.MeshBuilder.CreateSphere('sphere', { diameter }, this.scene);
                    this._generalParams(sphere, generalParams);

                    return sphere;
                },

                createBox({ size, ...generalParams }) {
                    const box = new BABYLON.MeshBuilder.CreateBox("box", {
                        width: size.x,
                        depth: size.z,
                        height: size.y
                    }, this.scene);
                    this._generalParams(box, generalParams);

                    return box;
                },

                setPhysics({ impostor = 'SphereImpostor', mass = 0, restitution = 0, friction = 0.7 }) {
                    this.physicsImpostor = new BABYLON.PhysicsImpostor(this, BABYLON.PhysicsImpostor[impostor], {
                        mass,
                        friction,
                        restitution,
                        group:4,
                        mask:128
                    }, this.scene);
                },

                _generalParams(mesh, { position, rotation = new BABYLON.Vector3(0, 0, 0), material }) {
                    mesh.position.set(position.x, position.y, position.z);
                    mesh.rotation.set(rotation.x, rotation.y, rotation.z);
                    mesh.material = material;
                    mesh.setPhysics = this.setPhysics;
                },
            };

            const createRollerWalls = () => {
                let alpha = 2.06;

                const wall1 = mesh.createBox({
                    size: { x: 12, y: 12, z: 12 },
                    position: { x: 0, y: -1, z: 9.8 },
                    material: materials['yellow']
                });

                const wall2 = mesh.createBox({
                    size: { x: 12, y: 12, z: 12 },
                    position: { x: 0, y: -1, z: 23.4 },
                    material: materials['yellow']
                });

                Array.from([wall1, wall2], item => {
                    item.isVisible = false;
                    item.setPhysics({ impostor: 'BoxImpostor', restitution: 1, friction: 1,
                        group:0,
                        mask:254 });
                });

                spheresWall = Array.from({ length: 45 }, () => {
                    const sphere = mesh.createSphere({
                        diameter: 2.5,
                        position: { x: -0.22 + (6.45 * Math.cos(alpha)), y: -0.6 + (6.45 * Math.sin(alpha)), z: 16.3 },
                        material: materials['yellow'],
                    });

                    sphere.setPhysics({ restitution: 0, friction: 0,
                        group:4,
                        mask:254 });
                    // sphere.isVisible = false;
                    alpha += 0.15;

                    return sphere;
                });
            };

            const createRotor = () => {
                const holder = mesh.createSphere({
                    diameter: 0.7,
                    position: { x: -0.25, y: -0.65, z: 16.7 },
                    material: materials['yellow']
                });

                // holder.isVisible = false;

                holder.setPhysics({});

                const joint1 = new BABYLON.HingeJoint({
                    mainPivot: new BABYLON.Vector3(0, 0, 0),
                    connectedPivot: new BABYLON.Vector3(0, 0, 0),
                    mainAxis: new BABYLON.Vector3(0, 0, 1),
                    connectedAxis: new BABYLON.Vector3(0, 0, 1),
                    nativeParams: {}
                });

                return {
                    holderAddJoint(rotor) {
                        holder.physicsImpostor.addJoint(rotor.physicsImpostor, joint1);
                    },

                    runRotor(forceFactor) {
                        joint1.setMotor(forceFactor);
                    }
                }
            };

            const createRoller = (scene, rotor) => {
                const assetsManager = new BABYLON.AssetsManager(scene);
                const meshTask = assetsManager.addMeshTask('Roller', "", 'https://raw.githubusercontent.com/Hriz256/lotto/master/src/assets/roller/', 'roller.obj');

                meshTask.onSuccess = ({ loadedMeshes }) => {
                    const roller = new BABYLON.Mesh('roller', scene);

                    Array.from(loadedMeshes, (item, index) => {
                        item.rotation.y = Math.PI;
                        item.scaling = new BABYLON.Vector3(0.137, 0.137, 0.137);

                        if (index === 3) {
                            item.scaling = new BABYLON.Vector3(0.139, 0.139, 0.139);
                            item.position = new BABYLON.Vector3(-2.8, -10.3, 1.25);
                            item.computeWorldMatrix();
                            item.bakeCurrentTransformIntoVertices(true);

                            item.setPhysics = mesh.setPhysics;
                            item.setPhysics({ impostor: 'MeshImpostor', mass: 20, friction: 0,
                        group:4,
                        mask:254 });

                            rotor.holderAddJoint(item);
                        } else {
                            item.position = new BABYLON.Vector3(-3, -10.8, 18);
                            // item.isVisible = false
                            item.parent = roller
                        }
                    });

                    Array.from([
                        'Volum_Base_Glass_Mesh',
                        'Import_glass001_Mesh.029',
                        'Import_glass002_Mesh.040',
                        'Import_glass003_Mesh.051',
                        'Import_glass_Mesh.007',
                        'export_Glass_Mesh.018'
                    ], item => scene.getMeshByName(item).material = materials.glass);

                    scene.getMeshByName('Body_Mesh.002').material = materials.createTexture({
                        texture: 'roller/Body_Base_Color',
                        format: 'png'
                    });
                };

                assetsManager.load();
            };


            const rotor = createRotor();
            createRoller(scene, rotor);

            createRollerWalls();

            return scene;
        }

        engine = createDefaultEngine();
        if (!engine) throw 'engine should not be null.';
        scene = createScene();;
        sceneToRender = scene

        engine.runRenderLoop(function () {
            if (sceneToRender) {
                sceneToRender.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
